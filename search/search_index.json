{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home \u00b6 This module was developed using and was intended for Roblox Studio. The module and all of its content was written by zblox164 . You can get the module in the Roblox library here . Placement Service is an advanced kit that allows you to create a fully functional sandbox tycoon style placement system without going through the hassle of creating one from scratch yourself! With countless polished and easy to use features, anyone with basic Luau knowledge can make a unique and secure placement system in minutes! It is also the easiest published placement system kit on the Roblox platform! Benefits \u00b6 It's Easy to Learn. \u00b6 Placement Service was designed with beginner programmers in mind. It only requires beginner Luau scripting to get the system up and working while still maintaining a strong feature set for those who like to tinker! Is Polished and Reliable. \u00b6 Over the period that Placement Service has been in development, I've had time to test and polish every feature included! Regularly Updated. \u00b6 Placement Service is always being updated with bugs fixes, performance improvements, and feature updates! It's Secure. \u00b6 Placement Service is fully filtering enabled compatible to make secure gameplay easy for all of your players! It's Highly Customizable. \u00b6 Placement Service is packed with features so that you can make a placement system that is perfect for your game! Don't want interpolation? Don't want a grid system? Changing these is as simple as unchecking a checkbox ! Features \u00b6 Accurate movement system (grid/no grid) Angle Tilting Ability to toggle selection boxes on or off during placement Auto anchor Auto place system Collisions Cool down timer for placement Cross platform support for PC, XBOX and Mobile Custom callback functions on placement Customizable colors when placing and colliding Custom keybinds for cancelling placement, change floor and rotation Custom Range for models to be placed in. Where if the model is too far away from the character you cant place it Floors system (able to raise and lower the object) Grid fade in/out toggles Haptic feedback (XBOX) Interpolation (smoothing) No Plot Placement (does not require a plot) Optional audible feedback Rotation Server side placement Stackable objects Signals/Events system Ignorable objects The module was released May 22, of 2020.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#benefits","text":"","title":"Benefits"},{"location":"#its-easy-to-learn","text":"Placement Service was designed with beginner programmers in mind. It only requires beginner Luau scripting to get the system up and working while still maintaining a strong feature set for those who like to tinker!","title":" It's Easy to Learn."},{"location":"#is-polished-and-reliable","text":"Over the period that Placement Service has been in development, I've had time to test and polish every feature included!","title":" Is Polished and Reliable."},{"location":"#regularly-updated","text":"Placement Service is always being updated with bugs fixes, performance improvements, and feature updates!","title":" Regularly Updated."},{"location":"#its-secure","text":"Placement Service is fully filtering enabled compatible to make secure gameplay easy for all of your players!","title":" It's Secure."},{"location":"#its-highly-customizable","text":"Placement Service is packed with features so that you can make a placement system that is perfect for your game! Don't want interpolation? Don't want a grid system? Changing these is as simple as unchecking a checkbox !","title":" It's Highly Customizable."},{"location":"#features","text":"Accurate movement system (grid/no grid) Angle Tilting Ability to toggle selection boxes on or off during placement Auto anchor Auto place system Collisions Cool down timer for placement Cross platform support for PC, XBOX and Mobile Custom callback functions on placement Customizable colors when placing and colliding Custom keybinds for cancelling placement, change floor and rotation Custom Range for models to be placed in. Where if the model is too far away from the character you cant place it Floors system (able to raise and lower the object) Grid fade in/out toggles Haptic feedback (XBOX) Interpolation (smoothing) No Plot Placement (does not require a plot) Optional audible feedback Rotation Server side placement Stackable objects Signals/Events system Ignorable objects The module was released May 22, of 2020.","title":"Features"},{"location":"API/","text":"API \u00b6 This is the official API for Placement Service. This page will include every feature contained within the module and show examples of how they work. Constructors \u00b6 PlacementService.new() \u00b6 PlacementService . new ( int GridUnit , instance Itemlocation , Enum RotateKey , Enum TerminateKey , Enum RaiseKey , Enum LowerKey , Enum RotateKeyXBOX , Enum TerminateKeyXBOX , Enum RaiseKeyXBOX , Enum LowerKeyXBOX , Instance ( s ) IgnoredObjects ...) | PlacementInfo Creates and returns a new PlacementInfo object. Application local players = game : GetService ( \"Players\" ) local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local player = players . LocalPlayer local mouse = player : GetMouse () local remote = replicatedStorage . remotes : WaitForChild ( \"requestPlacement\" ) local button = script . Parent local PlacementService = require ( replicatedStorage . modules : WaitForChild ( \"PlacementService\" )) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown , -- XBOX KeyCodes objectA , objectB , objectC ... ) Methods \u00b6 PlacementInfo:activate() \u00b6 PlacementInfo : activate ( string ModelName , instance ItemHolder , instance Plot , bool StackableToggle , bool RotationType , bool AutoPlaceToggle ) | void Activates a placement session. Application local players = game : GetService ( \"Players\" ) local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local player = players . LocalPlayer local mouse = player : GetMouse () local remote = replicatedStorage . remotes : WaitForChild ( \"requestPlacement\" ) local button = script . Parent local PlacementService = require ( replicatedStorage . modules : WaitForChild ( \"PlacementService\" )) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) PlacementInfo:noPlotActivate() \u00b6 PlacementInfo : noPlotActivate ( string objectName , obj placedObjectsLocation , bool smartRotation , bool autoPlace ) | void Activates placement without the requirement of a plot. Application Equivalent to PlacementInfo:activate() except removes the dependencies of a plot. PlacementInfo:requestPlacement() \u00b6 PlacementInfo : requestPlacement ( RBXScriptSignal PlacementRF , function callback ) | void Requests and starts the placement process on the server. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local function callback () -- This is optional print ( \"An object has been placed\" ) end button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote , callback ) end ) Callback can also be invoke as shown below: -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote , function () print ( \"An object has been placed\" ) end ) end ) PlacementInfo:getCurrentState() \u00b6 PlacementInfo : getCurrentState () | string Returns a string that corresponds to the current state the module is in. Application -- Assume variables were declared above ^ local contextActionService = game : GetService ( \"ContextActionService\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local function placeItem () placementInfo : requestPlacement ( remote ) if placementInfo : getCurrentState () == \"inactive\" then contextActionService : UnbindAction ( \"place\" ) end end button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) contextActionService : BindAction ( \"place\" , placeItem , false , Enum . UserInputType . MouseButton1 ) end ) PlacementInfo:pauseCurrentState() \u00b6 PlacementInfo : pauseCurrentState () | void Pauses the current state that the module is in. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) -- Pauses the current state of the module if state == \"out-of_range\". while true do task . wait () if placementInfo : getCurrentState () == \"out-of-range\" then placementInfo : pauseCurrentState () end end PlacementInfo:resume() \u00b6 PlacementInfo : resume () | void Resumes any state that has been paused. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) -- Pauses the current state of the module if state == \"out-of_range\" for 5 seconds. while true do task . wait () if placementInfo : getCurrentState () == \"out-of-range\" then placementInfo : pauseCurrentState () task . wait ( 5 ) placementInfo : resume () end end PlacementInfo:getPlatform() \u00b6 PlacementInfo : getPlatform () | string Returns the current platform used by the player in the form of a string. Platforms: \"Mobile\", \"Console\", or \"PC\". Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local connection local function clientPlacement () if placementInfo : getCurrentState () == \"inactive\" and not placementInfo : getPlatform () == \"Mobile\" then contextActionService : UnbindAction ( \"place\" ) elseif placementInfo : getCurrentState () == \"inactive\" and placementInfo : getPlatform () == \"Mobile\" then -- Disconnect mobile inputs connection : Disconnect () end placementInfo : requestPlacement ( remote ) end local function startPlacement ( id ) -- Handle platforms if placementInfo : getPlatform () ~= \"Mobile\" then contextActionService : BindAction ( \"place\" , clientPlacement , false , Enum . UserInputType . MouseButton1 , Enum . KeyCode . ButtonR1 ) else -- Handle mobile inputs connection = placementInfo . MobileUI . place . MouseButton1Click : Connect ( clientPlacement ) end placementInfo : activate ( id , workspace . base . itemHolder , workspace . base , true , false , false ) end button . MouseButton1Click : Connect ( function () startPlacement ( \"Chair\" ) end ) PlacementInfo:raise() \u00b6 PlacementInfo : raise () | void Manually raises the objects floor/default y value. Used mainly for mobile support. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local connection1 local connection2 local function raise () placementInfo : raise () end local function clientPlacement () if placementInfo : getCurrentState () == \"inactive\" and not placementInfo : getPlatform () == \"Mobile\" then contextActionService : UnbindAction ( \"place\" ) elseif placementInfo : getCurrentState () == \"inactive\" and placementInfo : getPlatform () == \"Mobile\" then connection1 : Disconnect () connection2 : Disconnect () end placementInfo : requestPlacement ( remote ) end local function startPlacement ( id ) -- Handle platforms if placementInfo : getPlatform () ~= \"Mobile\" then contextActionService : BindAction ( \"place\" , clientPlacement , false , Enum . UserInputType . MouseButton1 , Enum . KeyCode . ButtonR1 ) else connection1 = placementInfo . MobileUI . place . MouseButton1Click : Connect ( clientPlacement ) connection2 = placementInfo . MobileUI . raise . MouseButton1Click : Connect ( raise ) end placementInfo : activate ( id , workspace . base . itemHolder , workspace . base , true , false , false ) end button . MouseButton1Click : Connect ( function () startPlacement ( \"Chair\" ) end ) PlacementInfo:lower() \u00b6 PlacementInfo : lower () | void Manually lowers the objects floor/default y value. Used mainly for mobile support. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local connection1 local connection2 local function lower () placementInfo : lower () end local function clientPlacement () if placementInfo : getCurrentState () == \"inactive\" and not placementInfo : getPlatform () == \"Mobile\" then contextActionService : UnbindAction ( \"place\" ) elseif placementInfo : getCurrentState () == \"inactive\" and placementInfo : getPlatform () == \"Mobile\" then connection1 : Disconnect () connection2 : Disconnect () end placementInfo : requestPlacement ( remote ) end local function startPlacement ( id ) -- Handle platforms if placementInfo : getPlatform () ~= \"Mobile\" then contextActionService : BindAction ( \"place\" , clientPlacement , false , Enum . UserInputType . MouseButton1 , Enum . KeyCode . ButtonR1 ) else connection1 = placementInfo . MobileUI . place . MouseButton1Click : Connect ( clientPlacement ) connection2 = placementInfo . MobileUI . raise . MouseButton1Click : Connect ( lower ) end placementInfo : activate ( id , workspace . base . itemHolder , workspace . base , true , false , false ) end button . MouseButton1Click : Connect ( function () startPlacement ( \"Chair\" ) end ) PlacementInfo:rotate() \u00b6 PlacementInfo : rotate () | void Manually rotates the objects. Used mainly for mobile support. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local connection1 local connection2 local function rotate () placementInfo : rotate () end local function clientPlacement () if placementInfo : getCurrentState () == \"inactive\" and not placementInfo : getPlatform () == \"Mobile\" then contextActionService : UnbindAction ( \"place\" ) elseif placementInfo : getCurrentState () == \"inactive\" and placementInfo : getPlatform () == \"Mobile\" then connection1 : Disconnect () connection2 : Disconnect () end placementInfo : requestPlacement ( remote ) end local function startPlacement ( id ) -- Handle platforms if placementInfo : getPlatform () ~= \"Mobile\" then contextActionService : BindAction ( \"place\" , clientPlacement , false , Enum . UserInputType . MouseButton1 , Enum . KeyCode . ButtonR1 ) else connection1 = placementInfo . MobileUI . place . MouseButton1Click : Connect ( clientPlacement ) connection2 = placementInfo . MobileUI . raise . MouseButton1Click : Connect ( rotate ) end placementInfo : activate ( id , workspace . base . itemHolder , workspace . base , true , false , false ) end button . MouseButton1Click : Connect ( function () startPlacement ( \"Chair\" ) end ) PlacementInfo:terminate() \u00b6 PlacementInfo : terminate () | void Manually terminates a placement session. Equivelent to pressing the terminate key on PC or XBOX while placing. Is also used for terminating placement sessions on mobile. Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) cancelRemote . OnClientEvent : Connect ( function () placementInfo : terminate () end ) Alternative Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local connection1 local connection2 local function terminate () placementInfo : terminate () end local function clientPlacement () if placementInfo : getCurrentState () == \"inactive\" and not placementInfo : getPlatform () == \"Mobile\" then contextActionService : UnbindAction ( \"place\" ) elseif placementInfo : getCurrentState () == \"inactive\" and placementInfo : getPlatform () == \"Mobile\" then connection1 : Disconnect () connection2 : Disconnect () end placementInfo : requestPlacement ( remote ) end local function startPlacement ( id ) -- Handle platforms if placementInfo : getPlatform () ~= \"Mobile\" then contextActionService : BindAction ( \"place\" , clientPlacement , false , Enum . UserInputType . MouseButton1 , Enum . KeyCode . ButtonR1 ) else connection1 = placementInfo . MobileUI . place . MouseButton1Click : Connect ( clientPlacement ) connection2 = placementInfo . MobileUI . raise . MouseButton1Click : Connect ( terminate ) end placementInfo : activate ( id , workspace . base . itemHolder , workspace . base , true , false , false ) end button . MouseButton1Click : Connect ( function () startPlacement ( \"Chair\" ) end ) PlacementInfo:editAttribute() \u00b6 PlacementInfo : editAttribute ( string attributeName , any input ) | void Changes the value of the attribute inputted to the value specified (if the attribute exists and the value is compatible with the attribute). Application -- Assume variables were declared above ^ local lerp = true local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) lerpToggle . MouseButton1Click : Connect ( function () lerp = not lerp placementInfo : editAttribute ( \"Interpolation\" , lerp ) end ) PlacementInfo:haltPlacement() \u00b6 PlacementInfo : haltPlacement () | void Pauses the automatic placement. This does not function like PlacementInfo:terminate() as it does not cancel placement. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , true ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) mouse . Button1Up : Connect ( function () placementInfo : haltPlacement () end ) Signals \u00b6 PlacementInfo.Activated \u00b6 PlacementInfo . Activated | void Fires on each activation. Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) placementInfo . Activated : Connect ( function () print ( \"Activated placement!\" ) end ) PlacementInfo.Placed \u00b6 PlacementInfo . Placed | string Fires once an object has been placed and returns it. Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) placementInfo . Placed : Connect ( function ( objectName ) print ( objectName ) end ) PlacementInfo.Rotated \u00b6 PlacementInfo . Rotated | void Fires once each time the object has been rotated either from user input or a manual rotation (PlacementInfo:rotate()). Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) placementInfo . Rotated : Connect ( function () print ( \"Rotated!\" ) end ) PlacementInfo.Terminated \u00b6 PlacementInfo . Terminated | void Fires once each time placement has been terminated either from user input or a manual termination (PlacementInfo:terminate()). Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) placementInfo . Terminated : Connect ( function () print ( \"Terminated!\" ) end ) PlacementInfo.Collided \u00b6 PlacementInfo . Collided | instance Fires once each time the object collides with an object and returns the collided object. Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) placementInfo . Collided : Connect ( function ( hit ) print ( tostring ( hit )) end ) PlacementInfo.ChangedFloors \u00b6 PlacementInfo . ChangedFloors | bool Fires once each time the Y level has been changed either from user input or a manual change (PlacementInfo:raise/lower()). Returns a boolean value (true up, false down) as the direction. Does not account for stacking. Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) placementInfo . ChangedFloors : Connect ( function ( direction ) print ( direction ) end ) Data \u00b6 Attributes table \u00b6 Name Type AngleTilt bool AngleTiltAmplitude float AudioFeedback bool AudioVolume float BuildModePlacement bool CollisionColor3 Color3 Collisions bool DisplayGridTexture bool EnableFloors bool FloorStep int GridFadeIn bool GridFadeOut bool GridTextureID string HapticFeedback bool HapticVibrationAmount float HitboxColor3 Color3 HitboxTransparency float IncludeSelectionBox bool InstantActivation bool Interpolation bool InvertAngleTilt bool LerpSpeed float LineThickness float LineTransparency float MaxHeight int MaxRange int MoveByGrid bool PlacementCooldown float PreferSignals bool RemoveCollisionsIfIgnored bool RotationStep int SelectionBoxCollisionColor3 Color3 SelectionBoxColor3 Color3 SmartDisplay bool SoundID string TargetFPS float TransparencyDelta float TransparentModel bool UseHighlights bool Version string Return type table \u00b6 Functions \u00b6 Function Return Type PlacementService.new() PlacementInfo PlacementInfo:activate() void PlacementInfo:noPlotActivate() void PlacementInfo:requestPlacement() void PlacementInfo:terminate() void PlacementInfo:raise() void PlacementInfo:lower() void PlacementInfo:rotate() void PlacementInfo:getCurrentState() string PlacementInfo:getPlatform() string PlacementInfo:pauseCurrentState() void PlacementInfo:resume() void PlacementInfo:editAttribute() void PlacementInfo:haltPlacement() void Signals \u00b6 Signal Return Type PlacementInfo.Activated void PlacementInfo.Placed string PlacementInfo.Rotated void PlacementInfo.Terminated void PlacementInfo.Collided instance PlacementInfo.ChangedFloors void State List \u00b6 State When active movement When the object is not colliding or out of range and is not requesting placement. placing Active on the frame before requesting a placement to the server. colliding When the object collides with another object on the plane/plot. inactive When no other state is active and the module is not in use by the player. out-of-range When the object is not colliding but is out of the range set by the developer. Error List \u00b6 Code Message 101 Your trying to activate placement too fast! Please slow down 201 Error code 201: The object that the model is moving on is not scaled correctly. Consider changing it. 301 Error code 301: You have improperly setup your callback function. Please input a valid callback 401 Error code 401: Grid size is too close to the plot size. To fix this, try lowering the grid size. 501 Error code 501: Cannot find a surface to place on. Please make sure one is available.","title":"API"},{"location":"API/#api","text":"This is the official API for Placement Service. This page will include every feature contained within the module and show examples of how they work.","title":"API"},{"location":"API/#constructors","text":"","title":"Constructors"},{"location":"API/#placementservicenew","text":"PlacementService . new ( int GridUnit , instance Itemlocation , Enum RotateKey , Enum TerminateKey , Enum RaiseKey , Enum LowerKey , Enum RotateKeyXBOX , Enum TerminateKeyXBOX , Enum RaiseKeyXBOX , Enum LowerKeyXBOX , Instance ( s ) IgnoredObjects ...) | PlacementInfo Creates and returns a new PlacementInfo object. Application local players = game : GetService ( \"Players\" ) local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local player = players . LocalPlayer local mouse = player : GetMouse () local remote = replicatedStorage . remotes : WaitForChild ( \"requestPlacement\" ) local button = script . Parent local PlacementService = require ( replicatedStorage . modules : WaitForChild ( \"PlacementService\" )) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown , -- XBOX KeyCodes objectA , objectB , objectC ... )","title":"PlacementService.new()"},{"location":"API/#methods","text":"","title":"Methods"},{"location":"API/#placementinfoactivate","text":"PlacementInfo : activate ( string ModelName , instance ItemHolder , instance Plot , bool StackableToggle , bool RotationType , bool AutoPlaceToggle ) | void Activates a placement session. Application local players = game : GetService ( \"Players\" ) local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local player = players . LocalPlayer local mouse = player : GetMouse () local remote = replicatedStorage . remotes : WaitForChild ( \"requestPlacement\" ) local button = script . Parent local PlacementService = require ( replicatedStorage . modules : WaitForChild ( \"PlacementService\" )) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end )","title":"PlacementInfo:activate()"},{"location":"API/#placementinfonoplotactivate","text":"PlacementInfo : noPlotActivate ( string objectName , obj placedObjectsLocation , bool smartRotation , bool autoPlace ) | void Activates placement without the requirement of a plot. Application Equivalent to PlacementInfo:activate() except removes the dependencies of a plot.","title":"PlacementInfo:noPlotActivate()"},{"location":"API/#placementinforequestplacement","text":"PlacementInfo : requestPlacement ( RBXScriptSignal PlacementRF , function callback ) | void Requests and starts the placement process on the server. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local function callback () -- This is optional print ( \"An object has been placed\" ) end button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote , callback ) end ) Callback can also be invoke as shown below: -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote , function () print ( \"An object has been placed\" ) end ) end )","title":"PlacementInfo:requestPlacement()"},{"location":"API/#placementinfogetcurrentstate","text":"PlacementInfo : getCurrentState () | string Returns a string that corresponds to the current state the module is in. Application -- Assume variables were declared above ^ local contextActionService = game : GetService ( \"ContextActionService\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local function placeItem () placementInfo : requestPlacement ( remote ) if placementInfo : getCurrentState () == \"inactive\" then contextActionService : UnbindAction ( \"place\" ) end end button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) contextActionService : BindAction ( \"place\" , placeItem , false , Enum . UserInputType . MouseButton1 ) end )","title":"PlacementInfo:getCurrentState()"},{"location":"API/#placementinfopausecurrentstate","text":"PlacementInfo : pauseCurrentState () | void Pauses the current state that the module is in. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) -- Pauses the current state of the module if state == \"out-of_range\". while true do task . wait () if placementInfo : getCurrentState () == \"out-of-range\" then placementInfo : pauseCurrentState () end end","title":"PlacementInfo:pauseCurrentState()"},{"location":"API/#placementinforesume","text":"PlacementInfo : resume () | void Resumes any state that has been paused. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) -- Pauses the current state of the module if state == \"out-of_range\" for 5 seconds. while true do task . wait () if placementInfo : getCurrentState () == \"out-of-range\" then placementInfo : pauseCurrentState () task . wait ( 5 ) placementInfo : resume () end end","title":"PlacementInfo:resume()"},{"location":"API/#placementinfogetplatform","text":"PlacementInfo : getPlatform () | string Returns the current platform used by the player in the form of a string. Platforms: \"Mobile\", \"Console\", or \"PC\". Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local connection local function clientPlacement () if placementInfo : getCurrentState () == \"inactive\" and not placementInfo : getPlatform () == \"Mobile\" then contextActionService : UnbindAction ( \"place\" ) elseif placementInfo : getCurrentState () == \"inactive\" and placementInfo : getPlatform () == \"Mobile\" then -- Disconnect mobile inputs connection : Disconnect () end placementInfo : requestPlacement ( remote ) end local function startPlacement ( id ) -- Handle platforms if placementInfo : getPlatform () ~= \"Mobile\" then contextActionService : BindAction ( \"place\" , clientPlacement , false , Enum . UserInputType . MouseButton1 , Enum . KeyCode . ButtonR1 ) else -- Handle mobile inputs connection = placementInfo . MobileUI . place . MouseButton1Click : Connect ( clientPlacement ) end placementInfo : activate ( id , workspace . base . itemHolder , workspace . base , true , false , false ) end button . MouseButton1Click : Connect ( function () startPlacement ( \"Chair\" ) end )","title":"PlacementInfo:getPlatform()"},{"location":"API/#placementinforaise","text":"PlacementInfo : raise () | void Manually raises the objects floor/default y value. Used mainly for mobile support. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local connection1 local connection2 local function raise () placementInfo : raise () end local function clientPlacement () if placementInfo : getCurrentState () == \"inactive\" and not placementInfo : getPlatform () == \"Mobile\" then contextActionService : UnbindAction ( \"place\" ) elseif placementInfo : getCurrentState () == \"inactive\" and placementInfo : getPlatform () == \"Mobile\" then connection1 : Disconnect () connection2 : Disconnect () end placementInfo : requestPlacement ( remote ) end local function startPlacement ( id ) -- Handle platforms if placementInfo : getPlatform () ~= \"Mobile\" then contextActionService : BindAction ( \"place\" , clientPlacement , false , Enum . UserInputType . MouseButton1 , Enum . KeyCode . ButtonR1 ) else connection1 = placementInfo . MobileUI . place . MouseButton1Click : Connect ( clientPlacement ) connection2 = placementInfo . MobileUI . raise . MouseButton1Click : Connect ( raise ) end placementInfo : activate ( id , workspace . base . itemHolder , workspace . base , true , false , false ) end button . MouseButton1Click : Connect ( function () startPlacement ( \"Chair\" ) end )","title":"PlacementInfo:raise()"},{"location":"API/#placementinfolower","text":"PlacementInfo : lower () | void Manually lowers the objects floor/default y value. Used mainly for mobile support. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local connection1 local connection2 local function lower () placementInfo : lower () end local function clientPlacement () if placementInfo : getCurrentState () == \"inactive\" and not placementInfo : getPlatform () == \"Mobile\" then contextActionService : UnbindAction ( \"place\" ) elseif placementInfo : getCurrentState () == \"inactive\" and placementInfo : getPlatform () == \"Mobile\" then connection1 : Disconnect () connection2 : Disconnect () end placementInfo : requestPlacement ( remote ) end local function startPlacement ( id ) -- Handle platforms if placementInfo : getPlatform () ~= \"Mobile\" then contextActionService : BindAction ( \"place\" , clientPlacement , false , Enum . UserInputType . MouseButton1 , Enum . KeyCode . ButtonR1 ) else connection1 = placementInfo . MobileUI . place . MouseButton1Click : Connect ( clientPlacement ) connection2 = placementInfo . MobileUI . raise . MouseButton1Click : Connect ( lower ) end placementInfo : activate ( id , workspace . base . itemHolder , workspace . base , true , false , false ) end button . MouseButton1Click : Connect ( function () startPlacement ( \"Chair\" ) end )","title":"PlacementInfo:lower()"},{"location":"API/#placementinforotate","text":"PlacementInfo : rotate () | void Manually rotates the objects. Used mainly for mobile support. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local connection1 local connection2 local function rotate () placementInfo : rotate () end local function clientPlacement () if placementInfo : getCurrentState () == \"inactive\" and not placementInfo : getPlatform () == \"Mobile\" then contextActionService : UnbindAction ( \"place\" ) elseif placementInfo : getCurrentState () == \"inactive\" and placementInfo : getPlatform () == \"Mobile\" then connection1 : Disconnect () connection2 : Disconnect () end placementInfo : requestPlacement ( remote ) end local function startPlacement ( id ) -- Handle platforms if placementInfo : getPlatform () ~= \"Mobile\" then contextActionService : BindAction ( \"place\" , clientPlacement , false , Enum . UserInputType . MouseButton1 , Enum . KeyCode . ButtonR1 ) else connection1 = placementInfo . MobileUI . place . MouseButton1Click : Connect ( clientPlacement ) connection2 = placementInfo . MobileUI . raise . MouseButton1Click : Connect ( rotate ) end placementInfo : activate ( id , workspace . base . itemHolder , workspace . base , true , false , false ) end button . MouseButton1Click : Connect ( function () startPlacement ( \"Chair\" ) end )","title":"PlacementInfo:rotate()"},{"location":"API/#placementinfoterminate","text":"PlacementInfo : terminate () | void Manually terminates a placement session. Equivelent to pressing the terminate key on PC or XBOX while placing. Is also used for terminating placement sessions on mobile. Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) cancelRemote . OnClientEvent : Connect ( function () placementInfo : terminate () end ) Alternative Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) local connection1 local connection2 local function terminate () placementInfo : terminate () end local function clientPlacement () if placementInfo : getCurrentState () == \"inactive\" and not placementInfo : getPlatform () == \"Mobile\" then contextActionService : UnbindAction ( \"place\" ) elseif placementInfo : getCurrentState () == \"inactive\" and placementInfo : getPlatform () == \"Mobile\" then connection1 : Disconnect () connection2 : Disconnect () end placementInfo : requestPlacement ( remote ) end local function startPlacement ( id ) -- Handle platforms if placementInfo : getPlatform () ~= \"Mobile\" then contextActionService : BindAction ( \"place\" , clientPlacement , false , Enum . UserInputType . MouseButton1 , Enum . KeyCode . ButtonR1 ) else connection1 = placementInfo . MobileUI . place . MouseButton1Click : Connect ( clientPlacement ) connection2 = placementInfo . MobileUI . raise . MouseButton1Click : Connect ( terminate ) end placementInfo : activate ( id , workspace . base . itemHolder , workspace . base , true , false , false ) end button . MouseButton1Click : Connect ( function () startPlacement ( \"Chair\" ) end )","title":"PlacementInfo:terminate()"},{"location":"API/#placementinfoeditattribute","text":"PlacementInfo : editAttribute ( string attributeName , any input ) | void Changes the value of the attribute inputted to the value specified (if the attribute exists and the value is compatible with the attribute). Application -- Assume variables were declared above ^ local lerp = true local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) lerpToggle . MouseButton1Click : Connect ( function () lerp = not lerp placementInfo : editAttribute ( \"Interpolation\" , lerp ) end )","title":"PlacementInfo:editAttribute()"},{"location":"API/#placementinfohaltplacement","text":"PlacementInfo : haltPlacement () | void Pauses the automatic placement. This does not function like PlacementInfo:terminate() as it does not cancel placement. Application -- Assume variables were declared above ^ local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , true ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) mouse . Button1Up : Connect ( function () placementInfo : haltPlacement () end )","title":"PlacementInfo:haltPlacement()"},{"location":"API/#signals","text":"","title":"Signals"},{"location":"API/#placementinfoactivated","text":"PlacementInfo . Activated | void Fires on each activation. Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) placementInfo . Activated : Connect ( function () print ( \"Activated placement!\" ) end )","title":"PlacementInfo.Activated"},{"location":"API/#placementinfoplaced","text":"PlacementInfo . Placed | string Fires once an object has been placed and returns it. Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) placementInfo . Placed : Connect ( function ( objectName ) print ( objectName ) end )","title":"PlacementInfo.Placed"},{"location":"API/#placementinforotated","text":"PlacementInfo . Rotated | void Fires once each time the object has been rotated either from user input or a manual rotation (PlacementInfo:rotate()). Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) placementInfo . Rotated : Connect ( function () print ( \"Rotated!\" ) end )","title":"PlacementInfo.Rotated"},{"location":"API/#placementinfoterminated","text":"PlacementInfo . Terminated | void Fires once each time placement has been terminated either from user input or a manual termination (PlacementInfo:terminate()). Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) placementInfo . Terminated : Connect ( function () print ( \"Terminated!\" ) end )","title":"PlacementInfo.Terminated"},{"location":"API/#placementinfocollided","text":"PlacementInfo . Collided | instance Fires once each time the object collides with an object and returns the collided object. Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) placementInfo . Collided : Connect ( function ( hit ) print ( tostring ( hit )) end )","title":"PlacementInfo.Collided"},{"location":"API/#placementinfochangedfloors","text":"PlacementInfo . ChangedFloors | bool Fires once each time the Y level has been changed either from user input or a manual change (PlacementInfo:raise/lower()). Returns a boolean value (true up, false down) as the direction. Does not account for stacking. Application -- Assume variables were declared above ^ local cancelRemote = replicatedStorage : WaitForChild ( \"cancelPlacement\" ) local placementInfo = PlacementService . new ( 2 , -- Grid Unit replicatedStorage . models , -- Item Location Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , -- PC KeyCodes Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown -- XBOX KeyCodes ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Chair\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) placementInfo . ChangedFloors : Connect ( function ( direction ) print ( direction ) end )","title":"PlacementInfo.ChangedFloors"},{"location":"API/#data","text":"","title":"Data"},{"location":"API/#attributes-table","text":"Name Type AngleTilt bool AngleTiltAmplitude float AudioFeedback bool AudioVolume float BuildModePlacement bool CollisionColor3 Color3 Collisions bool DisplayGridTexture bool EnableFloors bool FloorStep int GridFadeIn bool GridFadeOut bool GridTextureID string HapticFeedback bool HapticVibrationAmount float HitboxColor3 Color3 HitboxTransparency float IncludeSelectionBox bool InstantActivation bool Interpolation bool InvertAngleTilt bool LerpSpeed float LineThickness float LineTransparency float MaxHeight int MaxRange int MoveByGrid bool PlacementCooldown float PreferSignals bool RemoveCollisionsIfIgnored bool RotationStep int SelectionBoxCollisionColor3 Color3 SelectionBoxColor3 Color3 SmartDisplay bool SoundID string TargetFPS float TransparencyDelta float TransparentModel bool UseHighlights bool Version string","title":"Attributes table"},{"location":"API/#return-type-table","text":"","title":"Return type table"},{"location":"API/#functions","text":"Function Return Type PlacementService.new() PlacementInfo PlacementInfo:activate() void PlacementInfo:noPlotActivate() void PlacementInfo:requestPlacement() void PlacementInfo:terminate() void PlacementInfo:raise() void PlacementInfo:lower() void PlacementInfo:rotate() void PlacementInfo:getCurrentState() string PlacementInfo:getPlatform() string PlacementInfo:pauseCurrentState() void PlacementInfo:resume() void PlacementInfo:editAttribute() void PlacementInfo:haltPlacement() void","title":"Functions"},{"location":"API/#signals_1","text":"Signal Return Type PlacementInfo.Activated void PlacementInfo.Placed string PlacementInfo.Rotated void PlacementInfo.Terminated void PlacementInfo.Collided instance PlacementInfo.ChangedFloors void","title":"Signals"},{"location":"API/#state-list","text":"State When active movement When the object is not colliding or out of range and is not requesting placement. placing Active on the frame before requesting a placement to the server. colliding When the object collides with another object on the plane/plot. inactive When no other state is active and the module is not in use by the player. out-of-range When the object is not colliding but is out of the range set by the developer.","title":"State List"},{"location":"API/#error-list","text":"Code Message 101 Your trying to activate placement too fast! Please slow down 201 Error code 201: The object that the model is moving on is not scaled correctly. Consider changing it. 301 Error code 301: You have improperly setup your callback function. Please input a valid callback 401 Error code 401: Grid size is too close to the plot size. To fix this, try lowering the grid size. 501 Error code 501: Cannot find a surface to place on. Please make sure one is available.","title":"Error List"},{"location":"Changelogs/","text":"2020-05-22 V1.0.0 - Details: - The module has been released. 2020-05-24 V1.1.0 - Details: - Fixed bugs - Improved snapping - Added Placement cooldowns 2020-05-26 V1.1.1 Details: - Fixed bugs 2020-06-15 V1.1.1 - Released YouTube tutorial 2020-07-07 V1.1.2 - Details: - Fixed bugs 2020-07-15 V1.1.3 - Details: - Optimized math (now uses x * 0.5 instead of x / 2) - Code is more readable as a result of comments - Added a maxRange variable which controls how far the model can be placed from the character 2020-07-28 V1.1.4 - Details: - Added better round function - Improved input (now uses ContextActionService instead of UserInputService) 2020-07-30 V1.1.5 - Details: - Fixed a problem where keybinds were set automaticly and not by the user 2020-08-01 V1.1.6 - Details: - Fixed issue where exploters could leave the plot - Minor improvements to code readability 2020-08-02 V1.1.7 - Details: - Improved accuracy when moving models - Minor improvements and bug fixes 2020-10-03 V1.1.8 - Details: - Improved timing when starting placement; models will instantly be at the mouse position when activating placement - Fixed major bugs: Terminate function should no longer error. Activate function should no longer produce errors - Typo fixes - Minor improvements and fixes 2020-10-04 V1.1.9 - Details: - Added new setting, \"instantActivation\". See the description of it below - Added new selection box feature. You can now toggle a selection box around your model when placing - Added gridFadeIn and gridFadeOut toggles. See the description of it below - Minor improvements and fixes - Typo fixes 2020-10-06 V1.2.0 - Details: - Urgent and critical bug fixed - Added collision color support for selection boxes - Fixed issue with the module not resetting target filter - Added thumbnail 2021-2-10 V1.3.0 - Details: - Minor bug fixes - New autoplace feature - Added auto anchor - Minor improvements - Improved thumbnail 2021-05-06 V1.4.0 - Details: Module changes - Added Xbox support - Added Xbox haptic feedback - Added Sound feedback on placement - Added editAttribute() which now allows you to change settings such as interpolation - Module now uses attributes instead of variables for user settings - Major bug fixes and improvements Noteable fix: Movement is now relative to the plot. Noteable fix: Stacking now ignores objects not within the your item location folder Noteable change: Modified state \"in-active\" to \"inactive\". Other changes - Moved changelogs to separate script - Moved API to separate script - Updated Extras script - Updated API 2021-06-29 V1.4.1 - Details: Module changes - Major bug fixes Noteable fix: Fixed issue where models motion becomes inverted when on rotated planes. - Minor improvements Noteable improvement: The module now uses the new Pivot API. Other changes - Fixed typo in the API 2021-11-15 V1.5.0 - Details: Module changes - Added signals that will fire when collisions, out of range, rotation, or placement is detected. - Added new attribute \"PreferSignals\" so that signals to not replace callbacks if they are preferred. Note that there is only one callback (on placement) and this disables signals. - Added new non plot dependent placement. - Minor Improvements 2021-11-28 V1.5.1 - Details: Module changes - Fixed callbacks not being in the previous version even when PreferSignals is set to false. Other changes - Fixed typos for version numbers 2021-12-21 V1.5.2 - Details: Modules changes - Added mobile support. - Added functions for getting the device type, manual rotation, and manual floor changes. - Fixed logic bug when changing floors. 2022-02-07 V1.5.3 - Details: Module changes - Minor code improvements - Removed xbox controls dependencies (will now just default to presets) - Removed requirement for mobile ui to be strictly named \"MobileUI\" - Fixed rotation/bounds bug - Improved error messaging 2022-02-18 V1.5.4 - Details: Module changes - Minor Improvements - Minor Fixes 2022-04-20 V1.5.5 - Details: Module changes - Fixed callbacks being unusable - Minor Improvements - Minor Fixes 2022-05-23 V1.5.6 - Details: Module changes - Renamed from \"Placement Module V3\" to \"Placement Service\" 2022-06-15 V1.5.7 - Details: Module changes - Added new attributes: AngleTilt [FEATURE] AngleTiltAmplitude InverseAngleTilt TargetFPS [FEATURE] - Improved grid fade in/out to now use tween service in place of loops - Minor Improvements and fixes 2022-08-19 V1.5.8 - Details: Module changes - Migrated to use raycasts instead of the mouse object - Improved position accuracy - Improved stacking - Improved collision detection for interpolation and angle tilting - Positions are now relative to plots rotation - Added new parameter in the new() constructor to allow for ignored objects - Added new attribute: RemoveCollisionsIfIgnored - Minor improvements and fixes 2022-12-15 V1.5.9 - Details: Module changes - Fixed calculation issue with server side bounds - Fixed issue with MaxRange attribute - Improved mobile stacking - Added new attribute: CharacterCollisions [FEATURE] - Changed PlacementInfo properties: gridsize is now GridUnit items is now Items version is now Version - Minor code improvements - Minor bug fixes 2023-04-10 V1.6.0 - Details: Module changes - Major code improvements - Minor bug fixes - Fixed issue with CharacterCollisions - Fixed issue with included server code - Added new attribute: UseHighlights [FEATURE] 2023-04-13 V1.6.1 - Details Module changes - Bug fixes from last update - Server code bug fix","title":"Changelogs"},{"location":"Roadmap/","text":"Roadmap 2023 \u00b6 This is the official roadmap for Placement Service. Planned features are features I plan to release in the current year, but complications may occur, and any feature is subject to be deferred and or cancelled. Released features are shown in the released features section for the current year. Current version 1.6.1 2023 \u00b6 Planned Features Deferred Features Cancelled Features Released Features Optional auto terminate attribute (placement ends when you leave the plot's range) Improved Stacking (adjusts for different faces) Row Placement Ability to use highlights instead of selection boxes Previous years \u00b6 2020 2021 2022 Module was released Placement cooldowns Placement range system Replaced UserInputService in place of ContextActionService Added InstantActivation setting Added optional selection boxes Added grid fade in/out setting Added collision color for selection boxes Auto Place Auto Anchor XBOX Support Audible Feedback Replaced in script Settings with attributes Added callbacks on placement Movement now uses the Pivot API Fixed inverse movement bug Built in signals for collisions, placement etc... Remove dependencies on plot (allow for open world placement) Mobile Support Removed xbox controls dependencies Angle Interpolation Replace for loops with tween service Movement relative to rotated plots Ability to ignore certain objects Added new attribute \"CharacterCollisions\"","title":"Roadmap 2023"},{"location":"Roadmap/#roadmap-2023","text":"This is the official roadmap for Placement Service. Planned features are features I plan to release in the current year, but complications may occur, and any feature is subject to be deferred and or cancelled. Released features are shown in the released features section for the current year. Current version 1.6.1","title":"Roadmap 2023"},{"location":"Roadmap/#2023","text":"Planned Features Deferred Features Cancelled Features Released Features Optional auto terminate attribute (placement ends when you leave the plot's range) Improved Stacking (adjusts for different faces) Row Placement Ability to use highlights instead of selection boxes","title":"2023"},{"location":"Roadmap/#previous-years","text":"2020 2021 2022 Module was released Placement cooldowns Placement range system Replaced UserInputService in place of ContextActionService Added InstantActivation setting Added optional selection boxes Added grid fade in/out setting Added collision color for selection boxes Auto Place Auto Anchor XBOX Support Audible Feedback Replaced in script Settings with attributes Added callbacks on placement Movement now uses the Pivot API Fixed inverse movement bug Built in signals for collisions, placement etc... Remove dependencies on plot (allow for open world placement) Mobile Support Removed xbox controls dependencies Angle Interpolation Replace for loops with tween service Movement relative to rotated plots Ability to ignore certain objects Added new attribute \"CharacterCollisions\"","title":"Previous years"},{"location":"Troubleshooting/","text":"Troubleshooting and FAQ \u00b6 Warning This module was designed specially for sandbox tycoons. This kit does NOT support systems of wall/floor/roof (AKA bloxburg placement) placement and is very limited on open world placement systems (similar to that of Minecraft). Please be aware of this before continuing. If you're having issues with the module, this page will attempt to address that and answer some frequent questions. Keep in mind, this page is very limited, and isn't updated as often as the rest of the wiki. Troubleshooting \u00b6 If the module does not work, make sure you're using the latest version. If you are not, you can try replacing the module with a newer version and see if that fixes the issue. Try looking through the categories to find your problem. I have a warning The module doesn't work at all Placement is broken \"Error code 201: The object that the model is moving on is not scaled correctly. Consider changing it.\" This warning indicates the plot you are using is not a multiple of the grid unit you have set. Either change your grid unit or rescale your plot. You can check to see if your grid size will work by printing the plot size modulus (%) the grid unit. If the value is == 0, you should not have any issues but any other value means the plot is not divisable by the grid size (you will get offsets). \"Error code 301: You have improperly setup your callback function. Please input a valid callback\" This warning indicates you have either disabled signals and didn't want to use callbacks or you've setup your callback function correctly. To fix this, input a valid callback function or enable signals and use them instead. \"Your trying to activate placement too fast! Please slow down\" This warning indicates you are attempting to activate placement too fast. Make sure you are not trying to activate placement in a loop or in a RunService method like :BindToRenderStep() . \"Error code 401: Grid size is too close to the plot size. To fix this, try lowering the grid size.\" This error indicates the chosen grid size is too large for the plot you are using. To fix this, reduce the grid size or increase the plot size. \"Error code 501: Cannot find a surface to place on. Please make sure one is available.\" This error indicates the module could not find a surface to place on (only applies to placements without plots). Make sure you have inputted all required parameters in the new() function and the activate() function. Confirm with the code sample below that you include all of the parameters: PlacementService . new ( int GridUnit , instance Itemlocation , Enum RotateKey , Enum TerminateKey , Enum RaiseKey , Enum LowerKey , Enum RotateKeyXBOX , Enum TerminateKeyXBOX , Enum RaiseKeyXBOX , Enum LowerKeyXBOX ) The activate function requires it's own set of parameters. Check to make sure you have all of them: PlacementInfo : activate ( string ModelName , instance ItemHolder , instance Plot , bool StackableToggle , bool RotationType , bool AutoPlaceToggle ) Remember XBOX Controls are not required and will default to their internal values if not included. The requestPlacement() function does not require you to include it's second parameter. It only requires you to pass a remote function. Callbacks are optional. You wont be able to add the later parameters though. Make sure your object exists and has a valid primary part. Objects that fail to satisfy this requirement will cause the module to error and will not work. Make sure you have correctly implemented the server side code. Placement will not work unless everything is setup correctly on the client and server. A common issue is that you may not have a valid path for the remote function on the server. Make sure you input a valid path before play testing. FAQ \u00b6 Q. Wasn't this used to be named \"Placement Module V3\"? A. Yes! The module was changed from \"Placement Module V3\" to \"Placement Service\" since \"Placement Module V3\" isn't easy remember, and is hard tell what it is without using the module prior. Q. How do I delete objects? A. The module does not handle any features other than the placement system. This is one of those features so you will have to research this and implement it yourself. Q. How do I save my plot? A. The module does not handle any features other than the placement system. This is one of those features so you will have to research this and implement it yourself. Q. How would I add a bloxburg style placement system to your model? A. The module does unfortunately NOT handle this feature. This is merely just a standard placement system where you can move and place objects down. You will have to implement this feature on your own. Q. It is broken. How do I fix this? A. The most likely reason for this, is that you have incorrectly setup the module. You will have to fix your code to fix this 99% of the time. You can also try checking for a newer version of the module. Q. Is this module cross platform? A. Yes! This module supports XBOX, PC and Mobile devices! Q. Do I have to credit you for using this module? A. You do not have to credit me for the module, however it is appreciated due to the module taking many hours to develop. You cannot claim the system as your own.","title":"Troubleshooting and FAQ"},{"location":"Troubleshooting/#troubleshooting-and-faq","text":"Warning This module was designed specially for sandbox tycoons. This kit does NOT support systems of wall/floor/roof (AKA bloxburg placement) placement and is very limited on open world placement systems (similar to that of Minecraft). Please be aware of this before continuing. If you're having issues with the module, this page will attempt to address that and answer some frequent questions. Keep in mind, this page is very limited, and isn't updated as often as the rest of the wiki.","title":"Troubleshooting and FAQ"},{"location":"Troubleshooting/#troubleshooting","text":"If the module does not work, make sure you're using the latest version. If you are not, you can try replacing the module with a newer version and see if that fixes the issue. Try looking through the categories to find your problem. I have a warning The module doesn't work at all Placement is broken \"Error code 201: The object that the model is moving on is not scaled correctly. Consider changing it.\" This warning indicates the plot you are using is not a multiple of the grid unit you have set. Either change your grid unit or rescale your plot. You can check to see if your grid size will work by printing the plot size modulus (%) the grid unit. If the value is == 0, you should not have any issues but any other value means the plot is not divisable by the grid size (you will get offsets). \"Error code 301: You have improperly setup your callback function. Please input a valid callback\" This warning indicates you have either disabled signals and didn't want to use callbacks or you've setup your callback function correctly. To fix this, input a valid callback function or enable signals and use them instead. \"Your trying to activate placement too fast! Please slow down\" This warning indicates you are attempting to activate placement too fast. Make sure you are not trying to activate placement in a loop or in a RunService method like :BindToRenderStep() . \"Error code 401: Grid size is too close to the plot size. To fix this, try lowering the grid size.\" This error indicates the chosen grid size is too large for the plot you are using. To fix this, reduce the grid size or increase the plot size. \"Error code 501: Cannot find a surface to place on. Please make sure one is available.\" This error indicates the module could not find a surface to place on (only applies to placements without plots). Make sure you have inputted all required parameters in the new() function and the activate() function. Confirm with the code sample below that you include all of the parameters: PlacementService . new ( int GridUnit , instance Itemlocation , Enum RotateKey , Enum TerminateKey , Enum RaiseKey , Enum LowerKey , Enum RotateKeyXBOX , Enum TerminateKeyXBOX , Enum RaiseKeyXBOX , Enum LowerKeyXBOX ) The activate function requires it's own set of parameters. Check to make sure you have all of them: PlacementInfo : activate ( string ModelName , instance ItemHolder , instance Plot , bool StackableToggle , bool RotationType , bool AutoPlaceToggle ) Remember XBOX Controls are not required and will default to their internal values if not included. The requestPlacement() function does not require you to include it's second parameter. It only requires you to pass a remote function. Callbacks are optional. You wont be able to add the later parameters though. Make sure your object exists and has a valid primary part. Objects that fail to satisfy this requirement will cause the module to error and will not work. Make sure you have correctly implemented the server side code. Placement will not work unless everything is setup correctly on the client and server. A common issue is that you may not have a valid path for the remote function on the server. Make sure you input a valid path before play testing.","title":"Troubleshooting"},{"location":"Troubleshooting/#faq","text":"Q. Wasn't this used to be named \"Placement Module V3\"? A. Yes! The module was changed from \"Placement Module V3\" to \"Placement Service\" since \"Placement Module V3\" isn't easy remember, and is hard tell what it is without using the module prior. Q. How do I delete objects? A. The module does not handle any features other than the placement system. This is one of those features so you will have to research this and implement it yourself. Q. How do I save my plot? A. The module does not handle any features other than the placement system. This is one of those features so you will have to research this and implement it yourself. Q. How would I add a bloxburg style placement system to your model? A. The module does unfortunately NOT handle this feature. This is merely just a standard placement system where you can move and place objects down. You will have to implement this feature on your own. Q. It is broken. How do I fix this? A. The most likely reason for this, is that you have incorrectly setup the module. You will have to fix your code to fix this 99% of the time. You can also try checking for a newer version of the module. Q. Is this module cross platform? A. Yes! This module supports XBOX, PC and Mobile devices! Q. Do I have to credit you for using this module? A. You do not have to credit me for the module, however it is appreciated due to the module taking many hours to develop. You cannot claim the system as your own.","title":"FAQ"},{"location":"tutorial/","text":"Tutorial \u00b6 NOTE THIS IS OUTDATED. PLEASE USE THE DEV FORUM TUTORIAL FOR NOW How to use Placement Service Placement Service Current version: 1.6.1 Welcome to the complete guide on using Placement Service. It is a fully functional placement system kit that makes it easy to create a polished placement system in minutes! Note this tutorial was ported directly from the developer forum version. This will not cover anything that tutorial doesn't. Chapters \u00b6 The Initial Setup Creating Hitboxes Using Placement Service Customizing Placement Limitations Extra Info Before I go any further, you will need to get Placement Service . Once you have that, you can begin the tutorial. Notice \u00b6 As of version 1.5.6, this module was renamed from \u201cPlacement Module V3\u201d to \u201cPlacement Service\u201d. NOTE THIS IS OUTDATED. PLEASE USE THE DEV FORUM TUTORIAL FOR NOW Initial Setup \u00b6 The first thing you need to do is make sure you have your game setup to use the module. You will need at least one plot to place down objects as well as a Folder or Model to hold the placed objects in. I like to put a Folder located in the plot named something similar to itemHolder or tycoonItems . NOTICE - Your plot size must be a multiple of your grid size. The grid size is the number of units your model will move by. In our case, the unit we're using is studs. You will get a warning in the output otherwise. You will also need to make three folders located in ReplicatedStorage . One for remotes, one for models, and one for modules. Ungroup the module and place it in modules . You can leave models alone but do create a RemoteFunction called requestPlacement . Place this in remotes . You will also need a Script in ServerScriptService to handle the server placement. This is because the module is run entirely on the client. The final step is to add a way to start placement. In this tutorial, I will be using UI as it's going to be the easiest way to do it. Just add a ScreenGUi with a TextButton . You will also need a LocalScript in the button. This is what I have: That should be it for the setup. Creating hitboxes \u00b6 Creating custom hitboxes is relatively simple. You\u2019ll need a model to work with before moving on. You should already know how to construct models as this is not a tutorial on that and I will not go into detail about that here. Assuming you have a model ready, you can simply scale a part around the object creating the \u2018hitbox\u2019 for it. Then you can place that part in the model making it a child of that model. You now need to set this newly created part to the PrimaryPart of said model. Select the model using the cursor and in properties, you should see a option for the PrimaryPart . Click it and you will notice that your cursor has changed it\u2019s icon. You can now select the part you want to be the PrimaryPart in the workspace. You will probably want to lower the transparency of the PrimaryPart as it now covers the model. You should have something that looks similar to this now: Tip When building the models PrimaryPart /hitbox, you may want to put the grid texture on the plot your working on. This will help with making sure the model snaps to the grid. As long as it snaps to the grid while building, it should while placing. You can also set the snapping (located in the model tab) to whatever your grid unit will be. Now you can move that model to the models folder. Using Placement Service \u00b6 The next step is to open the LocalScript we created earlier. Define variables for Players as well as ReplicatedStorage . local players = game : GetService ( \"Players\" ) local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) We are going to need the mouse so we will also declare variables for the LocalPlayer and the Mouse object. local player = players . LocalPlayer local mouse = player : GetMouse () It is good practice to also get references to the RemoteFunction and TextButton instances since we will be using them. This is not required. local remote = replicatedStorage . remotes : WaitForChild ( \"requestPlacement\" ) local button = script . Parent The most important variable we need to define is one that returns the modules contents. local placementService = require ( replicatedStorage . modules : WaitForChild ( \"PlacementService\" )) Before you can use any of the functions in the module, we need to give it some information. We do this using the new() function. You call the function like this: local placementInfo = placementService.new() . The new function has multiple parameters you need to pass into it in order for it to work. int Grid size instance Item location Enum Rotate key keycode Enum Terminate/Cancel key keycode Enum Raise floor key keycode Enum Lower floor key keycode Enum Xbox Rotate keycode (has internal default if not input) Enum Xbox Terminate/Cancel key keycode (has internal default if not input) Enum Xbox Raise floor keycode (has internal default if not input) Enum Xbox Lower floor keycode (has internal default if not input) Instance(s) All objects input will be ignored by the mouse Once you input those parameters you should have something like this: local placementInfo = placementService . new ( 2 , replicatedStorage . models , Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown , objectA , objectB ... -- EXAMPLE OBJECTS - NOT REQUIRED ) Whenever you need to call a function on the module, you should use this new placementInfo variable . So far, you should have a script that looks similar to this: local players = game : GetService ( \"Players\" ) local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local player = players . LocalPlayer local mouse = player : GetMouse () local remote = replicatedStorage . remotes : WaitForChild ( \"requestPlacement\" ) local button = script . Parent local placementService = require ( replicatedStorage . modules : WaitForChild ( \"PlacementService\" )) local placementInfo = placementService . new ( 2 , replicatedStorage . models , Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown ) Now, this won't do anything yet. Before we continue, we need to add in some Events or more formally known as RBXScriptSignals . We only need two of them. One to listen for the the player to click the button and one to listen for a mouse click. button . MouseButton1Click : Connect ( function () end ) mouse . Button1Down : Connect ( function () end ) We are going to activate placement when the player clicks the button and request to place down the object when we click the mouse. Before this, unless you are planning on using this without a plot, remove the noPlotActivate() function in the module. This is to prevent exploiters from using it. To activate placement, we invoke the function activate() on the placementInfo variable and not the module reference. For this, make sure you are using a : and not a . to invoke this function. The parameters it takes are listed below: string Name of the model instance Item holder location (folder where the model will be placed) instance Plot location bool Toggles stacking bool Rotation type - If the model can rotate around 360 degrees or if it just rotates x amount of degrees back and fourth. bool Toggles auto-placement (set this to false for now) You should have something that looks like this now: button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Fence\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) Now you should have a working \"move around object system\". To make this a placement system, we need to call one last function. When we click the mouse, we want to send a request to the server to place the object. We can use the method requestPlacement() on the placement variable . This function takes two parameters. One for the remote event and one for the function you want to call on placement (optional). I will skip the callback for now and instead just input the remote. mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) This is all we need to do for the client. Your client code should look like this now: local players = game : GetService ( \"Players\" ) local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local player = players . LocalPlayer local mouse = player : GetMouse () local remote = replicatedStorage . remotes : WaitForChild ( \"requestPlacement\" ) local button = script . Parent local placementService = require ( replicatedStorage . modules : WaitForChild ( \"PlacementService\" )) local placementInfo = placementService . new ( 2 , replicatedStorage . models , Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Fence\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end If you notice, we still have a \"moving objects with mouse simulator\" here. To fix this, we need to add some code to our server script in ServerScriptService . This script is included with the module and can be found in the API script. The only thing you need to know in this script is where the place function is invoked from. On the very last line, you will see the remote function we created is what invokes/calls the function. You may have to change the location and name of the remote depending on how you followed this tutorial (if your remote is named different or is in a different location). local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) -- Ignore the top three functions -- Credit EgoMoose local function checkHitbox ( character , object ) if object then local collided = false local collisionPoint = object . PrimaryPart . Touched : Connect ( function () end ) local collisionPoints = object . PrimaryPart : GetTouchingParts () for i = 1 , # collisionPoints do if not collisionPoints [ i ]: IsDescendantOf ( object ) and not collisionPoints [ i ]: IsDescendantOf ( character ) then collided = true break end end collisionPoint : Disconnect () return collided end end local function checkBoundaries ( plot , primary ) local lowerXBound local upperXBound local lowerZBound local upperZBound local currentPos = primary . Position lowerXBound = plot . Position . X - ( plot . Size . X * 0.5 ) upperXBound = plot . Position . X + ( plot . Size . X * 0.5 ) lowerZBound = plot . Position . Z - ( plot . Size . Z * 0.5 ) upperZBound = plot . Position . Z + ( plot . Size . Z * 0.5 ) return currentPos . X > upperXBound or currentPos . X < lowerXBound or currentPos . Z > upperZBound or currentPos . Z < lowerZBound end local function handleCollisions ( char , item , c ) if c then if not checkHitbox ( char , item ) then item . PrimaryPart . Transparency = 1 return true else item : Destroy () return false end else item . PrimaryPart . Transparency = 1 return true end end --Ignore above local function place ( plr , name , location , prefabs , cframe , c , plot ) local item = prefabs : FindFirstChild ( name ): Clone () item . PrimaryPart . CanCollide = false item : PivotTo ( cframe ) if plot then if checkBoundaries ( plot , item . PrimaryPart ) then return end item . Parent = location return handleCollisions ( plr . Character , item , c ) else return handleCollisions ( plr . Character , item , c ) end end replicatedStorage . remotes . functions . requestPlacement . OnServerInvoke = place Now if you've done everything correctly, it should work! Before I move on, there are some built in functions that I will go over. void placement:noPlotActivate(string objectName, obj placedObjectsLocation, bool smartRotation, bool autoPlace) - Same as the regular activate except it doesn't require a plot. void placement:terminate() - Cancels placement void placement:pauseCurrentState() - Pauses the current state of the model void placement:resume() - Resumes the current state of the model. void placement:editAttribute(string attributeName, var input) - Changes the given attribute value based off of your input. void placement:haltPlacement() - Stops any automatic placement from running string placement:getCurrentState() - Returns the current state of the model I will briefly go over mobile support now. The module doesn't handle any functions with mobile, but does give you the ability to handle it on your own. What this means is to rotate the object, you have to invoke the action as appose to PC where the module handles this internally. This is because the module is designed to be as customizable as possible and requires you to use UI to trigger these actions. I didn't want to have a single template UI that everyone has to use so I am trading ease of use for flexibility. The module does include a UI template, however it does not require you to use it. You can customize the UI as much as you'd like. Just make sure the UI for mobile is placed into it's original location after. You can figure out if the user is playing on mobile by using the function placementInfo:getPlatform() . If it returns the string \"Mobile\", the user is on mobile. You can access the UI by saying: placementInfo.MobileUI . You can then detect input on the UI you have and use the functions placementInfo:lower() , placementInfo:raise() , placementInfo:rotate() , placement:terminate() , and placementInfo:requestPlacement() to handle those actions. -- Assume necessary variables are declared above ^ local function placementf () placement : requestPlacement ( place ) if placementInfo : getCurrentState () == \"inactive\" and not placementInfo : getPlatform () == \"Mobile\" then contextActionService : UnbindAction ( \"place\" ) end end local function raise () placementInfo : raise () end local function cancel () placementInfo : terminate () end local function rotate () placementInfo : rotate () end local function lower () placementInfo : lower () end local function startPlacement () if placementInfo : getPlatform () ~= \"Mobile\" then contextActionService : BindAction ( \"place\" , placementf , false , Enum . UserInputType . MouseButton1 , Enum . KeyCode . ButtonR1 ) else placementInfo . MobileUI . place . MouseButton1Click : Connect ( placementf ) placementInfo . MobileUI . raise . MouseButton1Click : Connect ( raise ) placementInfo . MobileUI . lower . MouseButton1Click : Connect ( lower ) placementInfo . MobileUI . cancel . MouseButton1Click : Connect ( cancel ) placementInfo . MobileUI . rotate . MouseButton1Click : Connect ( rotate ) end placementInfo : activate ( model . Name , itemHolder , plot , true , false , false ) end There are three things I skipped earlier that I will go over now. Those are autoPlacement , callbacks , and events/signals. Auto placement, if set to true when invoking the activate function, will make it so when you click to place the object down, it will automatically start placing as fast as you have it set to (placementCooldown determines this. See below for details). The first thing you will notice, is the fact that the placement doesn't automatically stop. This feature was added so you could hold the mouse button down to place multiple objects, however the module doesn't limit it for that purpose, so it doesn't stop placement automatically. Instead, you have to use the placement:haltPlacement() function to stop placement when you need to. As for callbacks, when you request a placement from the server, you have the option to invoke a function on placement. When you call placement:requestPlacement() , after you input the remote, you can optionally input a function as a callback. local placementService = require ( replicatedStorage . modules : WaitForChild ( \"PlacementService\" )) local placementInfo = placementService . new ( 2 , replicatedStorage . models , Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown ) local function callback () print ( \"An object was just placed\" ) end mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote , callback ) end --[[ You can also use callbacks like this: placementInfo:requestPlacement(remote, function() -- code end) ]] As of version 1.5.0, the placement module now includes it's own set of signals that can be used to trigger certain events after an \"event\" occurs while placing. Using the signals is as easy as using any other signal you've used before. Simply say placement.SIGNAL:Connect(function() -- code end) . Here's a list of all the signals the module offers: void placementInfo.Activated void placementInfo.Placed void placementInfo.Rotated void placementInfo.Terminated obj collidedObject placementInfo.Collided bool direction placementInfo.ChangedFloors (true = up, false = down) Keep in mind that before you attempt to use these signals, you need to make sure that PreferSignals is set to true. It is true by default, just keep in mind that this disables the callback feature (vice versa if set to false). Customizing Placement \u00b6 Now that you have a working placement system, it's time to configure it to make it your own! If you click on the module, you will see it has a list of attributes you can edit. They are all documented in the module, but I'll list them here as well: bools bool AngleTilt - Toggles if you want the object to tilt when moving (based on speed) bool InvertAngleTilt - Inverts the direction of the angle tilt bool Interpolation - Toggles if you want to have the model interpolate when moving (smooth movement) bool MoveByGrid - Toggles if you want the model to move by a grid or not bool Collisions - Toggles if the module will detect collisions or not bool BuildModePlacement - Toggles if you want to be able to continually place objects until canceled by the user manually bool DisplayGridTexture - Toggles if you want to display a grid texture when placing a model bool SmartDisplay - Toggles if the texture displayed will be scaled to fit the grid size. It is recommended you set this to false unless your grid size is less than 5 studs (requires displayGridTexture to be true). bool EnableFloors - Toggles if you want to be able to change floors while placing bool TransparentModel - Toggles if the model will appear transparent while placing bool InstantActivation - Changes if the model will glide to the mouse position or not (on activation) bool IncludeSelectionBox - If you want a selection box to be visible while placing bool GridFadeIn - If you want the grid to fade in when activating placement bool GridFadeOut - If you want the grid to fade out when ending placement bool AudibleFeedback - Toggles sound feedback on placement bool PreferSignals - Controls if you want to use signals or callbacks bool RemoveCollisionsIfIgnored - Toggles if the model itself will be transparent Color3 Color3 CollisionColor3 - The color of the hitbox when collision is detected Color3 HitboxColor3 - The color of the hitbox in any non collision state; any natural state. Color3 SelectionBoxColor3 - The color of the selection box (IncludeSelectionBox much be set to true) Color3 SelectionBoxCollisionColor3 - The color of the selection box when collision is detected Integers int MaxHeight - The max height one the Y axis the model can move to int FloorStep - The number of studs the model will move up/down when switching floors int RotationStep - The number of degrees the model will rotate int GridTextureScale - How large the StudsPerTileU/V is displayed (SmartDisplay must be set to false) int MaxRange - How far in studs the model can be away from the character while still being able to place. Numbers/Floats Number AngleTiltAmplitude - How much the object will tilt when moving. 0 = min, 10 = max Number HitboxTransparency - The transparency of the hitbox when placing Number TransparencyDelta - The transparency of the model itself when placing (TransparentModel must be true) Number LerpSpeed - speed of interpolation. 0 = no interpolation, 0.9 = major interpolation Number PlacementCooldown - The cooldown which the user has to wait before placing another object Number TargetFPS - The target constant FPS [IT IS RECOMMENEDED TO LEAVE THIS AT 60] Number LineThickness - How thick the line of the selection box is (IncludeSelectionBox must be set to \"true\") Number LineTransparency - How transparent the line of the selection box is (IncludeSelectionBox must be set to \"true\") Number AudioVolume - Volume of the sound feedback (AudibleFeedback must be set to true) Cross platform bool HapticFeedback - If you want a controller to vibrate when placing objects number HapticVibrationAmount - How large the vibration is when placing objects (value from 0, 1) Other string GridTextureID - ID of the texture you want to display on the plot (DisplayGridTexture must be true) string SoundID - ID of the sound played on Placement (requires audibleFeedback to true) string Version - Has no functionality. Simply displays the version. One other thing you can do to limit collisions of parts, is to toggle CanTouch to false. Any parts with this settings set to false will not be detected by the collision function. Limitations \u00b6 Now, as much as I'd like to say this is the perfect placement module , I just can't. One of the reasons being is this module is made specifically for sandbox tycoons , not open world games (although it can be used for open world games as of version 1.5.0 due to the noPlotActivate() function, but it may not work perfectly there). Extra Info \u00b6 Thank you for reading through this tutorial. I hope you found this helpful! If you didn't, please let me know what I should modify about the tutorial and or the module (I am open to criticisms). You don't have to give credit to use my module, though it is appreciated if given as this module has taken hundreds of hours to develop and polish. Here is a demo video . Here is the demo place to test the module out. Here is the copyable demo place Enjoy the module! Module Version Used - V1.5.8 Current version logs 2022-08-19 V1.5.8 - Details: Module changes Migrated to use raycasts instead of the mouse object Improved position accuracy Improved stacking Improved collision detection for interpolation and angle tilting Positions are now relative to plots rotation Added new parameter in the new() constructor to allow for ignored objects Added new attribute: RemoveCollisionsIfIgnored Minor improvements and fixes","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"NOTE THIS IS OUTDATED. PLEASE USE THE DEV FORUM TUTORIAL FOR NOW","title":"Tutorial"},{"location":"tutorial/#chapters","text":"The Initial Setup Creating Hitboxes Using Placement Service Customizing Placement Limitations Extra Info Before I go any further, you will need to get Placement Service . Once you have that, you can begin the tutorial.","title":"Chapters"},{"location":"tutorial/#notice","text":"As of version 1.5.6, this module was renamed from \u201cPlacement Module V3\u201d to \u201cPlacement Service\u201d. NOTE THIS IS OUTDATED. PLEASE USE THE DEV FORUM TUTORIAL FOR NOW","title":"Notice"},{"location":"tutorial/#initial-setup","text":"The first thing you need to do is make sure you have your game setup to use the module. You will need at least one plot to place down objects as well as a Folder or Model to hold the placed objects in. I like to put a Folder located in the plot named something similar to itemHolder or tycoonItems . NOTICE - Your plot size must be a multiple of your grid size. The grid size is the number of units your model will move by. In our case, the unit we're using is studs. You will get a warning in the output otherwise. You will also need to make three folders located in ReplicatedStorage . One for remotes, one for models, and one for modules. Ungroup the module and place it in modules . You can leave models alone but do create a RemoteFunction called requestPlacement . Place this in remotes . You will also need a Script in ServerScriptService to handle the server placement. This is because the module is run entirely on the client. The final step is to add a way to start placement. In this tutorial, I will be using UI as it's going to be the easiest way to do it. Just add a ScreenGUi with a TextButton . You will also need a LocalScript in the button. This is what I have: That should be it for the setup.","title":"Initial Setup"},{"location":"tutorial/#creating-hitboxes","text":"Creating custom hitboxes is relatively simple. You\u2019ll need a model to work with before moving on. You should already know how to construct models as this is not a tutorial on that and I will not go into detail about that here. Assuming you have a model ready, you can simply scale a part around the object creating the \u2018hitbox\u2019 for it. Then you can place that part in the model making it a child of that model. You now need to set this newly created part to the PrimaryPart of said model. Select the model using the cursor and in properties, you should see a option for the PrimaryPart . Click it and you will notice that your cursor has changed it\u2019s icon. You can now select the part you want to be the PrimaryPart in the workspace. You will probably want to lower the transparency of the PrimaryPart as it now covers the model. You should have something that looks similar to this now: Tip When building the models PrimaryPart /hitbox, you may want to put the grid texture on the plot your working on. This will help with making sure the model snaps to the grid. As long as it snaps to the grid while building, it should while placing. You can also set the snapping (located in the model tab) to whatever your grid unit will be. Now you can move that model to the models folder.","title":"Creating hitboxes"},{"location":"tutorial/#using-placement-service","text":"The next step is to open the LocalScript we created earlier. Define variables for Players as well as ReplicatedStorage . local players = game : GetService ( \"Players\" ) local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) We are going to need the mouse so we will also declare variables for the LocalPlayer and the Mouse object. local player = players . LocalPlayer local mouse = player : GetMouse () It is good practice to also get references to the RemoteFunction and TextButton instances since we will be using them. This is not required. local remote = replicatedStorage . remotes : WaitForChild ( \"requestPlacement\" ) local button = script . Parent The most important variable we need to define is one that returns the modules contents. local placementService = require ( replicatedStorage . modules : WaitForChild ( \"PlacementService\" )) Before you can use any of the functions in the module, we need to give it some information. We do this using the new() function. You call the function like this: local placementInfo = placementService.new() . The new function has multiple parameters you need to pass into it in order for it to work. int Grid size instance Item location Enum Rotate key keycode Enum Terminate/Cancel key keycode Enum Raise floor key keycode Enum Lower floor key keycode Enum Xbox Rotate keycode (has internal default if not input) Enum Xbox Terminate/Cancel key keycode (has internal default if not input) Enum Xbox Raise floor keycode (has internal default if not input) Enum Xbox Lower floor keycode (has internal default if not input) Instance(s) All objects input will be ignored by the mouse Once you input those parameters you should have something like this: local placementInfo = placementService . new ( 2 , replicatedStorage . models , Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown , objectA , objectB ... -- EXAMPLE OBJECTS - NOT REQUIRED ) Whenever you need to call a function on the module, you should use this new placementInfo variable . So far, you should have a script that looks similar to this: local players = game : GetService ( \"Players\" ) local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local player = players . LocalPlayer local mouse = player : GetMouse () local remote = replicatedStorage . remotes : WaitForChild ( \"requestPlacement\" ) local button = script . Parent local placementService = require ( replicatedStorage . modules : WaitForChild ( \"PlacementService\" )) local placementInfo = placementService . new ( 2 , replicatedStorage . models , Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown ) Now, this won't do anything yet. Before we continue, we need to add in some Events or more formally known as RBXScriptSignals . We only need two of them. One to listen for the the player to click the button and one to listen for a mouse click. button . MouseButton1Click : Connect ( function () end ) mouse . Button1Down : Connect ( function () end ) We are going to activate placement when the player clicks the button and request to place down the object when we click the mouse. Before this, unless you are planning on using this without a plot, remove the noPlotActivate() function in the module. This is to prevent exploiters from using it. To activate placement, we invoke the function activate() on the placementInfo variable and not the module reference. For this, make sure you are using a : and not a . to invoke this function. The parameters it takes are listed below: string Name of the model instance Item holder location (folder where the model will be placed) instance Plot location bool Toggles stacking bool Rotation type - If the model can rotate around 360 degrees or if it just rotates x amount of degrees back and fourth. bool Toggles auto-placement (set this to false for now) You should have something that looks like this now: button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Fence\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) Now you should have a working \"move around object system\". To make this a placement system, we need to call one last function. When we click the mouse, we want to send a request to the server to place the object. We can use the method requestPlacement() on the placement variable . This function takes two parameters. One for the remote event and one for the function you want to call on placement (optional). I will skip the callback for now and instead just input the remote. mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end ) This is all we need to do for the client. Your client code should look like this now: local players = game : GetService ( \"Players\" ) local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) local player = players . LocalPlayer local mouse = player : GetMouse () local remote = replicatedStorage . remotes : WaitForChild ( \"requestPlacement\" ) local button = script . Parent local placementService = require ( replicatedStorage . modules : WaitForChild ( \"PlacementService\" )) local placementInfo = placementService . new ( 2 , replicatedStorage . models , Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown ) button . MouseButton1Click : Connect ( function () placementInfo : activate ( \"Fence\" , workspace . base . itemHolder , workspace . base , true , false , false ) end ) mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote ) end If you notice, we still have a \"moving objects with mouse simulator\" here. To fix this, we need to add some code to our server script in ServerScriptService . This script is included with the module and can be found in the API script. The only thing you need to know in this script is where the place function is invoked from. On the very last line, you will see the remote function we created is what invokes/calls the function. You may have to change the location and name of the remote depending on how you followed this tutorial (if your remote is named different or is in a different location). local replicatedStorage = game : GetService ( \"ReplicatedStorage\" ) -- Ignore the top three functions -- Credit EgoMoose local function checkHitbox ( character , object ) if object then local collided = false local collisionPoint = object . PrimaryPart . Touched : Connect ( function () end ) local collisionPoints = object . PrimaryPart : GetTouchingParts () for i = 1 , # collisionPoints do if not collisionPoints [ i ]: IsDescendantOf ( object ) and not collisionPoints [ i ]: IsDescendantOf ( character ) then collided = true break end end collisionPoint : Disconnect () return collided end end local function checkBoundaries ( plot , primary ) local lowerXBound local upperXBound local lowerZBound local upperZBound local currentPos = primary . Position lowerXBound = plot . Position . X - ( plot . Size . X * 0.5 ) upperXBound = plot . Position . X + ( plot . Size . X * 0.5 ) lowerZBound = plot . Position . Z - ( plot . Size . Z * 0.5 ) upperZBound = plot . Position . Z + ( plot . Size . Z * 0.5 ) return currentPos . X > upperXBound or currentPos . X < lowerXBound or currentPos . Z > upperZBound or currentPos . Z < lowerZBound end local function handleCollisions ( char , item , c ) if c then if not checkHitbox ( char , item ) then item . PrimaryPart . Transparency = 1 return true else item : Destroy () return false end else item . PrimaryPart . Transparency = 1 return true end end --Ignore above local function place ( plr , name , location , prefabs , cframe , c , plot ) local item = prefabs : FindFirstChild ( name ): Clone () item . PrimaryPart . CanCollide = false item : PivotTo ( cframe ) if plot then if checkBoundaries ( plot , item . PrimaryPart ) then return end item . Parent = location return handleCollisions ( plr . Character , item , c ) else return handleCollisions ( plr . Character , item , c ) end end replicatedStorage . remotes . functions . requestPlacement . OnServerInvoke = place Now if you've done everything correctly, it should work! Before I move on, there are some built in functions that I will go over. void placement:noPlotActivate(string objectName, obj placedObjectsLocation, bool smartRotation, bool autoPlace) - Same as the regular activate except it doesn't require a plot. void placement:terminate() - Cancels placement void placement:pauseCurrentState() - Pauses the current state of the model void placement:resume() - Resumes the current state of the model. void placement:editAttribute(string attributeName, var input) - Changes the given attribute value based off of your input. void placement:haltPlacement() - Stops any automatic placement from running string placement:getCurrentState() - Returns the current state of the model I will briefly go over mobile support now. The module doesn't handle any functions with mobile, but does give you the ability to handle it on your own. What this means is to rotate the object, you have to invoke the action as appose to PC where the module handles this internally. This is because the module is designed to be as customizable as possible and requires you to use UI to trigger these actions. I didn't want to have a single template UI that everyone has to use so I am trading ease of use for flexibility. The module does include a UI template, however it does not require you to use it. You can customize the UI as much as you'd like. Just make sure the UI for mobile is placed into it's original location after. You can figure out if the user is playing on mobile by using the function placementInfo:getPlatform() . If it returns the string \"Mobile\", the user is on mobile. You can access the UI by saying: placementInfo.MobileUI . You can then detect input on the UI you have and use the functions placementInfo:lower() , placementInfo:raise() , placementInfo:rotate() , placement:terminate() , and placementInfo:requestPlacement() to handle those actions. -- Assume necessary variables are declared above ^ local function placementf () placement : requestPlacement ( place ) if placementInfo : getCurrentState () == \"inactive\" and not placementInfo : getPlatform () == \"Mobile\" then contextActionService : UnbindAction ( \"place\" ) end end local function raise () placementInfo : raise () end local function cancel () placementInfo : terminate () end local function rotate () placementInfo : rotate () end local function lower () placementInfo : lower () end local function startPlacement () if placementInfo : getPlatform () ~= \"Mobile\" then contextActionService : BindAction ( \"place\" , placementf , false , Enum . UserInputType . MouseButton1 , Enum . KeyCode . ButtonR1 ) else placementInfo . MobileUI . place . MouseButton1Click : Connect ( placementf ) placementInfo . MobileUI . raise . MouseButton1Click : Connect ( raise ) placementInfo . MobileUI . lower . MouseButton1Click : Connect ( lower ) placementInfo . MobileUI . cancel . MouseButton1Click : Connect ( cancel ) placementInfo . MobileUI . rotate . MouseButton1Click : Connect ( rotate ) end placementInfo : activate ( model . Name , itemHolder , plot , true , false , false ) end There are three things I skipped earlier that I will go over now. Those are autoPlacement , callbacks , and events/signals. Auto placement, if set to true when invoking the activate function, will make it so when you click to place the object down, it will automatically start placing as fast as you have it set to (placementCooldown determines this. See below for details). The first thing you will notice, is the fact that the placement doesn't automatically stop. This feature was added so you could hold the mouse button down to place multiple objects, however the module doesn't limit it for that purpose, so it doesn't stop placement automatically. Instead, you have to use the placement:haltPlacement() function to stop placement when you need to. As for callbacks, when you request a placement from the server, you have the option to invoke a function on placement. When you call placement:requestPlacement() , after you input the remote, you can optionally input a function as a callback. local placementService = require ( replicatedStorage . modules : WaitForChild ( \"PlacementService\" )) local placementInfo = placementService . new ( 2 , replicatedStorage . models , Enum . KeyCode . R , Enum . KeyCode . X , Enum . KeyCode . U , Enum . KeyCode . L , Enum . KeyCode . ButtonR1 , Enum . KeyCode . ButtonX , Enum . KeyCode . DPadUp , Enum . KeyCode . DPadDown ) local function callback () print ( \"An object was just placed\" ) end mouse . Button1Down : Connect ( function () placementInfo : requestPlacement ( remote , callback ) end --[[ You can also use callbacks like this: placementInfo:requestPlacement(remote, function() -- code end) ]] As of version 1.5.0, the placement module now includes it's own set of signals that can be used to trigger certain events after an \"event\" occurs while placing. Using the signals is as easy as using any other signal you've used before. Simply say placement.SIGNAL:Connect(function() -- code end) . Here's a list of all the signals the module offers: void placementInfo.Activated void placementInfo.Placed void placementInfo.Rotated void placementInfo.Terminated obj collidedObject placementInfo.Collided bool direction placementInfo.ChangedFloors (true = up, false = down) Keep in mind that before you attempt to use these signals, you need to make sure that PreferSignals is set to true. It is true by default, just keep in mind that this disables the callback feature (vice versa if set to false).","title":"Using Placement Service"},{"location":"tutorial/#customizing-placement","text":"Now that you have a working placement system, it's time to configure it to make it your own! If you click on the module, you will see it has a list of attributes you can edit. They are all documented in the module, but I'll list them here as well: bools bool AngleTilt - Toggles if you want the object to tilt when moving (based on speed) bool InvertAngleTilt - Inverts the direction of the angle tilt bool Interpolation - Toggles if you want to have the model interpolate when moving (smooth movement) bool MoveByGrid - Toggles if you want the model to move by a grid or not bool Collisions - Toggles if the module will detect collisions or not bool BuildModePlacement - Toggles if you want to be able to continually place objects until canceled by the user manually bool DisplayGridTexture - Toggles if you want to display a grid texture when placing a model bool SmartDisplay - Toggles if the texture displayed will be scaled to fit the grid size. It is recommended you set this to false unless your grid size is less than 5 studs (requires displayGridTexture to be true). bool EnableFloors - Toggles if you want to be able to change floors while placing bool TransparentModel - Toggles if the model will appear transparent while placing bool InstantActivation - Changes if the model will glide to the mouse position or not (on activation) bool IncludeSelectionBox - If you want a selection box to be visible while placing bool GridFadeIn - If you want the grid to fade in when activating placement bool GridFadeOut - If you want the grid to fade out when ending placement bool AudibleFeedback - Toggles sound feedback on placement bool PreferSignals - Controls if you want to use signals or callbacks bool RemoveCollisionsIfIgnored - Toggles if the model itself will be transparent Color3 Color3 CollisionColor3 - The color of the hitbox when collision is detected Color3 HitboxColor3 - The color of the hitbox in any non collision state; any natural state. Color3 SelectionBoxColor3 - The color of the selection box (IncludeSelectionBox much be set to true) Color3 SelectionBoxCollisionColor3 - The color of the selection box when collision is detected Integers int MaxHeight - The max height one the Y axis the model can move to int FloorStep - The number of studs the model will move up/down when switching floors int RotationStep - The number of degrees the model will rotate int GridTextureScale - How large the StudsPerTileU/V is displayed (SmartDisplay must be set to false) int MaxRange - How far in studs the model can be away from the character while still being able to place. Numbers/Floats Number AngleTiltAmplitude - How much the object will tilt when moving. 0 = min, 10 = max Number HitboxTransparency - The transparency of the hitbox when placing Number TransparencyDelta - The transparency of the model itself when placing (TransparentModel must be true) Number LerpSpeed - speed of interpolation. 0 = no interpolation, 0.9 = major interpolation Number PlacementCooldown - The cooldown which the user has to wait before placing another object Number TargetFPS - The target constant FPS [IT IS RECOMMENEDED TO LEAVE THIS AT 60] Number LineThickness - How thick the line of the selection box is (IncludeSelectionBox must be set to \"true\") Number LineTransparency - How transparent the line of the selection box is (IncludeSelectionBox must be set to \"true\") Number AudioVolume - Volume of the sound feedback (AudibleFeedback must be set to true) Cross platform bool HapticFeedback - If you want a controller to vibrate when placing objects number HapticVibrationAmount - How large the vibration is when placing objects (value from 0, 1) Other string GridTextureID - ID of the texture you want to display on the plot (DisplayGridTexture must be true) string SoundID - ID of the sound played on Placement (requires audibleFeedback to true) string Version - Has no functionality. Simply displays the version. One other thing you can do to limit collisions of parts, is to toggle CanTouch to false. Any parts with this settings set to false will not be detected by the collision function.","title":"Customizing Placement"},{"location":"tutorial/#limitations","text":"Now, as much as I'd like to say this is the perfect placement module , I just can't. One of the reasons being is this module is made specifically for sandbox tycoons , not open world games (although it can be used for open world games as of version 1.5.0 due to the noPlotActivate() function, but it may not work perfectly there).","title":"Limitations"},{"location":"tutorial/#extra-info","text":"Thank you for reading through this tutorial. I hope you found this helpful! If you didn't, please let me know what I should modify about the tutorial and or the module (I am open to criticisms). You don't have to give credit to use my module, though it is appreciated if given as this module has taken hundreds of hours to develop and polish. Here is a demo video . Here is the demo place to test the module out. Here is the copyable demo place Enjoy the module! Module Version Used - V1.5.8 Current version logs 2022-08-19 V1.5.8 - Details: Module changes Migrated to use raycasts instead of the mouse object Improved position accuracy Improved stacking Improved collision detection for interpolation and angle tilting Positions are now relative to plots rotation Added new parameter in the new() constructor to allow for ignored objects Added new attribute: RemoveCollisionsIfIgnored Minor improvements and fixes","title":"Extra Info"}]}